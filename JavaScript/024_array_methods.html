<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
</head>
<body>
    <script>

        let myObj = {
            val1 : 10,
            val2 : 30
        }

        /* 
        리터럴! 변수에 할당되기 전의 값 
        {} 객체 리터럴 (객체 키의 값의 쌍을 프로퍼티라고 부른다 va1키 10값)
        [] 배열 리터럴 (배열의 크기는 .length로 알 수 있다)
        "hello" 문자열의 리터럴
        1234 숫자의 리터럴
        */

        // let fruit = (["메론", "수박"], ["포도", "체리"]);

        // // 배열안 배열일때 ([].[])
        // let fish = ["정어리", "고등어", "참치"]
        // //일반적 배열 방법 []
        // let myobj = { val1: 10, val2: 30 }
        // //키와 value가 있을때 {}


        // 배열의 생성자 함수
        let myarray = []; // 쏘 간단

        let myArray = new Array(5);
        console.log(myArray);

        let myArray2 = new Array(5,3,2);
        console.log(myArray2);

        myArray2[0] // 3 인덱스로 값 접근 가능하고 값도 바꿀 수 있다
        "hello"[2]; // 문자열도 값에 접근할 수 있지만 값을 바꿀 순 없다 (불변성 immutable)

        console.log([1,2,3,4][2]); 
        
        // 중간에 값이 비어있는 배열도 만들 수 있고 접근도 가능하다 undefined JS는 가능

        // unshift() : 맨 앞에 요소 추가 <-> push는 요소 맨 뒤에 추가
        const cafe = ["coffee", "cake", "tea"]
        const count = cafe.unshift("bread");
        console.log(cafe); // (4) ['bread', 'coffee', 'cake', 'tea']
        console.log(count); // 4 <- unshift에서 반환하는 것은 배열의 길이
        // "반환한다"는 것은 값을 뽑아낸다, 값을 넘겨준다는 의미

        // shift() : 맨 앞 요소 지운다 <-> pop 맨 뒤 요소 지운다
        const firstElement = cafe.shift();
        console.log(cafe); // (3) ['coffee', 'cake', 'tea']

        // splice() : 특정한 인덱스 요소를 위치시킬 때
        // 배열.splice(요소를 위치시키고자 하는 인덱스, 제거할 요소 개수, 배열에 추가할 요소)
        cafe.splice(1,1,"bread"); // 두번째에 있는 1개 요소를 지우고 "bread"를 추가한다
        console.log(cafe); // (3) ['coffee', 'bread', 'tea']
        cafe.splice(-1,0,"cookie"); // 맨 끝이 0이고 -1은 끝에서 두번째
        console.log(cafe); // (4) ['coffee', 'bread', 'cookie', 'tea']

        // slice() : 배열 일부분을 잘라내서 새로운 배열로 반환
        // .slice(잘라낼 배열의 시작점의 인덱스, 잘라낼 배열의 종료지점 인덱스)
        const cafe2 = ["coffee", "cake", "tea", "cookie"]
        cafe2.slice(1,3);
        console.log(cafe2); // (4) ['coffee', 'cake', 'tea', 'cookie']
        // 문제 : 물고기가 아닌 것 slice로 출력
        let fish = ["정어리","고등어","돌고래","참치","고래상어","코끼리"]
        fish.slice(2,3); // ['돌고래']
        fish.slice(5); // ['코끼리']

        // reverse() : 순서 거꾸로 (많이 씀!) -> 원본 배열 변형시킨다
        const cafe3 = ["coffee", "cake", "tea", "cookie"]
        cafe3.reverse();
        console.log(cafe3); // (4) ['cookie', 'tea', 'cake', 'coffee']

        // indexOf() : 요소의 인덱스 찾고 싶을 때
        const cafe4 = ["coffee", "cake", "tea", "cookie"]
        console.log(cafe4.indexOf("tea")); // 2
        // 만약 배열 안에 찾는 똑같은 요소가 여러개라면 첫번째 인덱스만 출력되고 끝!

        // join() : 요소들을 연결해 하나의 값으로 만들기
        const cafe5 = ["coffee", "cake", "tea", "cookie"]
        console.log(cafe5.join("/")); // coffee/cake/tea/cookie
        console.log(cafe5.join("")); // coffeecaketeacookie 
        console.log(cafe5.join("/").split("/")); // (4) ['coffee', 'cake', 'tea', 'cookie'] <- 배열 가공했다가 다시 하고 싶으면 split
        console.log("hello world".split(" ")); // (2) ['hello', 'world']
        // 문자열에서 사용할 수 있는 함수를 메소드라고 하고  ... 체이닝 : 메소드 연달아서 연결~

        // includes() : 특정 요소가 포함되었는지 확인할 때
        // .incldes(찾는 요소, 어디서 찾고 싶은지 시작하는 인덱스)
        const cafe6 = ["coffee", "cake", "tea", "cookie"]
        console.log(cafe6.includes("bread")); // false
        console.log(cafe6.includes("cake",-3)); // true 

        // find() : 하나의 요소라도 조건을 만족하는지 확인 (최초 하나 찾으면 종료)
        const arr = [1,2,3,4,5,6,7,8,9,10];
        console.log(arr.find(i=>i>5)); // 6 
        // arr.find(function(i)){
        // return i === 2   
        // }) 
        // 2 (찾는 값이 없으면 undefined)

        // filter() : 모든 요소가 조건을 만족하는지 확인 (전부 다 찾는다)
        // 예시 참고

        // map() : 각각 요소에 함수를 호출할 때 (어레이로 만들어준다!!?)
        // 예시 참고
        /* 
        arr.map(i => i.name); 이것과
        arr.map(function (i) {
            return i.name
        });  이것이 같다!
        */

        // 문제 : map메소드를 이용해서 name의 값들을 원소로 하는 새로운 배열을 만들어 봅시다
        const studentList = [
            {
                id: 1, name: '원범', score: 'great'
            },
            {
                id: 2, name: '김진', score: 'nice'
            },
            {
                id: 3, name: '혜원', score: 'good'
            },
            {
                id: 4, name: '재현', score: 'too cool for school'
            }
        ]

        const newArray = studentList.map(
            function(i){
            return i.name
        }
        )
        // 콘솔창에 newArray 쳐보면 (4) ['원범', '김진', '혜원', '재현']
        const newArray2 = studentList.map(
            function(i){
            return i.name + "님";
        }
        )
        // 콘솔창에 newArray2 쳐보면 (4) ['원범님', '김진님', '혜원님', '재현님']

        // forEach() : 각각 요소를 실행하고 싶을 때. 요소를 하나씩 순환하면서 결과를 순환함 (어레이 X 맵보다 먼저 나옴)
        const Arr = [1,2,3,4,5,5,6,7,8,9,10]
        arr.forEach(function(i){
            return console.log(i)
        })
        // 1 ..... 10 까지 하나씩 출력

        // concat() : 배열을 합치거나 새로운 요소 추가
        const cafe7 = ["coffee"]
        console.log(cafe7.concat(["cake"])); // (2) ['coffee', 'cake']

        // sort() : 배열 내 요소를 정렬 (원본 배열 자체가 바뀜 알파벳 오름차순으로)
        // 문자열 예시 참조
        const numbers = [400, 200, 100];
        console.log(numbers.sort()); // (3) [100, 200, 400]
        const numbers2 = [40, 200, 100000];
        console.log(numbers2.sort()); // (3) [100000, 200, 40] ???? 문자열로 정렬 비교한다고 함 .. ; 1이 먼저고.. 2가 다음이고 .. 그런 거였다

        const arrNum = [13, 9, 10, 2];
        arrNum.sort(function(a, b) {
            console.log("a: "+a, "b :"+ b); // console.log(`a : ${a}`, `b: ${b}`)
            return a - b;
        })
        /*
        a: 9 b :13
        a: 10 b :9
        a: 10 b :13
        a: 10 b :9
        a: 2 b :10
        a: 2 b :9
        9랑 13 비교하면 ... 9-13 ==> 음수 (위치 바뀜)==> [9, 13, 10, 2]
        10 - 9 ==> 양수 ==> [9,13,10,2]
        10 - 13 ==> 음수 ==> [9,10,13,2]
        2 - 10 ==> 음수 ==> [9, 2, 10, 13]
        2 9- 9 ==> 음수 ==> [2, 9, 10, 13]
        */
        // arrNum 쳐보면

        /*
        if (true) {
            let num = 10;
        }
        전역이 아니라서 num 치면 안나옵니다 찾는 공간이 달라서
        */ 
    </script>
</body>
</html>