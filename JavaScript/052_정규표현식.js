https://regexr.com/5nvc2

// 제일 많이 쓰는 replace, match
("CEO kon hello CEO").replace(/CEO/,"CTO")
// 'CTO kon hello CEO'
("CEO kon hello CEO").replace(/CEO/g,"CTO")
// 'CTO kon hello CTO'
("CEO kon hello CEO").match(/CEO/g)
// (2) ['CEO', 'CEO']

// split 주의할 점
'!!!'.split('!')
// (4) ['', '', '', ''] 하나가 더 추가되어 4개
'a!a!a!'.split('!')
// (4) ['a', 'a', 'a', ''] 맨 뒤에 들어갔을 때 주의
'!a!a!a'.split('!')
// (4) ['', 'a', 'a', 'a'] 맨 앞에 들어갔을 때 주의
("CEO kon hello CEO").split(/CEO/g)
// (3) ['', ' kon hello ', '']

(/CEO/g).test("CEO kon hello CEO")
// true

// g는 global로 모든 문자열에서, m은 multiline으로 여러 라인에서 패턴을 찾겠다는 옵션

// 3. 일반문자열
/hello/g

// 4. 처음과 끝
/^hello/g // hello로 시작하는 것을 찾자
/hello$/g // hello로 끝나는 것을 찾자
/^hello$/g 

// 5. 모든 문자 매핑
/hello/g
/h.llo/g
/hello..world/g

// 6. 모든 문자 매핑
/h[eao]llo/g // 셋 중에 하나만 매핑

// 7. 범위
/h[a-zA-Z0-9]llo/g // a-z, A-Z, 0-9 중에서 하나만 찾는다 

// 8. 부정
/h[^ae]llo/g // a와 e가 아닌 것

// 9. 그루핑 규칙
/(on|ues|rida)/gm // 그룹 1로 3개 중 매칭되는 패턴 찾음
// Monday Tuesday Wednesday Thursday Friday Saturday Sunday 중에서 월,화,금 

10. 수량자// 10. 수량자
_* : 앞에 있는 문자가 0개 ~ N개
_+ : 앞에 있는 문자가 1개 ~ N개
_? : 앞에 있는 문자가 0개 ~ 1개

{3} : 3개
{3,} : 3개 이상
{1,3} : 1개 ~ 3개

_* : 앞에 있는 문자가 0개 ~ N개 ({0,})
_+ : 앞에 있는 문자가 1개 ~ N개({1,})
_? : 앞에 있는 문자가 0개 ~ 1개 ({0,1})

/[0-9]{3}[-.* ][0-9]{4}[-.* ][0-9]{4}/gm
//[0-9]{3} 0-9까지 3개 반복
//[-.*]이건 뭐지 중간값이 꼭 하나 나와야한다?

/[0-9]{2,3}[-.* ]?[0-9]{3,5}[-.* ]?[0-9]{4}/gm
/[0-9a-zA-Z]+@[0-9a-zA-Z]+.[a-zA-Z]+/gm

///////// 프로그래머스 정규표현식 예제 ///////////

// https://school.programmers.co.kr/learn/courses/30/lessons/49993

// ["BACDE", "CBADF", "AECB", "BDA"]

"CAZGBEUDKKCAEEEEEBEEEDEEEEEEEEE"

("CAZGBEUDKKA").match(/[CBD]/g)
("CEEEEEBEEEDEEEEEEEEE").match(/[CBD]/g)

let data = ["BACDE", "CBADF", "AECB", "BDA"]

for (i of data){
    // console.log(i)
    // console.log(i.match(/[CBD]/g))
    for (i of i.match(/[CBD]/g)) {

    }
}

// 코딩이 아니라 알고리즘만 설명한 것입니다.
// [원본, 매핑문자열]
[['C']['B']['D']]
[['C', 'B']['B', 'C']['D', 'D']]
[['C', 'C']['B', 'B']['D', 'D']] 결과 += 1
[['C', 'C']['B', 'B']['D', '']]  결과 += 1
[['C', 'B']['B', 'D']['D', '']]

const zip = (a, b) => a.map((v, i) => [v, b[i]])
zip([10, 20, 30], [1, 2, 3, 4])
zip([10, 20, 30], [1, 2])

/////////////////////

const zip = (a, b) => a.map((v, i) => [v, b[i]])

let data = ["BACDE", "CBADF", "AECB", "BDA"]

for (i of data){
    for ([x, y] of zip('CBD'.split(''), i.match(/[CBD]/g))) {
        console.log(x, y)
    }
    console.log('----------')
}

// 11. 캐릭터 클래스
/\w{5} /g
/\W/g
/\d/gm : 숫자
/\D/gm : not 숫자
/\s/gm : 스페이스
/\S/gm : not 스페이스

// 12. 이스케이프문자
/\[.*]/gm : 대괄호([]) 안에 감싸여진 문자열
/\(.*\)/gm : 소괄호 안에 감싸여진 문자열
/\\.*\//gm : 이미 사용되고 있는 특수문자로 감싸여진 문자열
/-.*-/gm : 이스케이프 문자를 사용할 필요가 없는 경우
/\^\^/gm : 이스케이프 문자가 필요한 경우
/:\)/gm : 이스케이프 문자가 필요한 경우

/*
- `^` : 문자열의 시작
- `$` : 문자열의 종료. 옵션에 따라 문장의 끝 또는 문서의 끝에 매치된다.
- `.` : 임의의 한 문자
- `[]`: 문자 클래스. 문자 클래스 안에 들어가 있는 문자는 그 바깥에서 하나의 문자로 취급된다.
- `^` : 문자 클래스 내에서 ^는 not
- `-` : ex) a-z는 a에서 z까지의 문자
- `|` : or를 나타냄
- `?` : 앞 문자가 없거나 하나 있음
- `+` : 앞 문자가 하나 이상임
- `*` : 앞 문자가 0개 이상임
- `{n,m}` : 앞 문자가 `n`개 이상 `m`개 이하. `{0,1}` 은 `?`와 같은 의미다.
- `{n,}` : 앞 문자가 `n`개 이상. 위의 형태에서 `m`이 생략된 형태이다. `{0,}` 이면 `*`와 같고 `{1,}` 이면 `+`와 같은 의미이다.
- `{n}` : 앞 문자가 정확히 `n`개. `{n,n}` 과 같은 의미이다.
- `()` : 하나의 패턴구분자 안에 서브 패턴을 지정해서 사용할 경우 괄호로 묶어주는 방식을 사용한다.
- `\s` : 공백문자
- `\b` : 문자와 공백 사이를 의미한다.
- `\d` : 숫자 [0-9]와 같다.
- `\t` : 탭문자
- `\w` : 단어 영문자+숫자+_(밑줄) [0-9a-zA-Z_]문자 이스케이프는 대문자로 적으면 반대를 의미한다.
[a-z] : a ~ z 사이의 문자를 찾음
[1-9] : 1 ~ 9 사이의 문자를 찾음
[abc] : a, b, c중 하나를 찾음
[^abc] : a, b, c를 제외한 문자를 찾음
.z : 아무 문자 하나를 . 기호로 찾으며 z로 끝남을 의미
a+ : a가 1개 이상을 의미함
a* : a가 0개 또는 그 이상을 의미함
s : 공백 문자를 찾음(스페이스, 탭 등), 대문자의 경우 아닌 문자를 찾음
d : 숫자를 찾음, 대문자의 경우 아닌 문자를 찾음
w : 알파벳 영문과 숫자와 언더바 _ 기호를 찾음, 대문자의 경우 아닌 문자를 찾음
t : 탭 공간을 찾음
g : 검색범위를 전역으로 확장
i : 대소문자를 구분하지 않음
gi : 검색 범위를 전역으로 확대하면서 대소문자를 구분하지 않음
m : 여러줄을 동시에 매칭함
*/
